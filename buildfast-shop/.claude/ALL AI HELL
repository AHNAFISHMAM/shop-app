Opus 4.1 Development Standards

1) Core Philosophy
	â€¢	Opus as an expert pair-programmer, not an oracle.
You decide direction and intent; Opus accelerates execution, refactoring, and reasoning.
	â€¢	Iterative collaboration beats single-shot prompting.
Start small, validate early, and expand scope once you confirm correctness.
	â€¢	Precision > verbosity.
Give Opus the exact outcome, format, and constraints you expect â€” the fewer assumptions, the better.
	â€¢	Structure your thinking in layers:
	â€¢	Intent (what you want)
	â€¢	Constraints (what must stay fixed)
	â€¢	Examples (reference code or schema)
	â€¢	Validation (tests, acceptance criteria)

â¸»

2) Project Setup

When using Opus 4.1 in a workspace or repo:

Recommended files:

/docs/Opus-Standards.md     # This document
/.opusrules                 # Behavioral constraints for code generation
/docs/prompts/              # Reusable prompt snippets
/tests/                     # Validation targets for AI-generated code

.opusrules (template)

# Opus 4.1 Project Rules

## Stack & Style
- Language: TypeScript preferred; fallback to JavaScript or Python when required.
- Frontend: React + TailwindCSS. Next.js App Router if SSR needed.
- Backend: Supabase or Express. Use REST or RPC endpoints, not ad hoc fetches.
- State: useState/useReducer (local), Context or Zustand/Redux (shared).
- Naming: PascalCase for components; camelCase for variables/functions.

## Output Constraints
- One file per code block unless explicitly allowed.
- Do not reformat unrelated code.
- Always include prop/interface definitions.
- Respect TypeScript strict rules; no any.

## Safety
- Never include real secrets or API keys.
- Assume all inputs are untrusted.
- Favor pure functions; minimize side effects.

## Behavior
- Keep responses modular.
- Add docstrings for complex logic.
- Prefer step-by-step or diff-based edits when updating existing code.


â¸»

3) Working With Opus 4.1 Effectively

a) Think in Prompt Phases

Phase	Goal	Example
Plan	Outline what you want	â€œPlan a simple authentication flow with email + password using Supabase.â€
Implement	Focus on one file/function	â€œImplement only the login function with error handling and loading state.â€
Test	Validate correctness	â€œWrite Jest tests for handleLogin() covering success/failure paths.â€
Refactor	Improve structure	â€œRefactor to extract reusable hooks; do not change functionality.â€
Document	Generate usage info	â€œWrite a README section describing how to extend the auth logic.â€

b) Chain prompts intentionally
	â€¢	Donâ€™t jump from â€œcreate appâ€ â†’ â€œadd analyticsâ€ â†’ â€œadd UI polishâ€ in one go.
Split into verified steps:

1. Generate skeleton â†’ 2. Add data model â†’ 3. Connect API â†’ 4. Style component



c) Validate every output

Use a simple 3-question review:
	1.	Does it compile/build?
	2.	Does it meet acceptance criteria?
	3.	Does it follow repo conventions?

â¸»

4) Ideal Prompt Blueprint (General Use)

Goal:
Create [feature/module/function] that does [specific action or behavior].

Context:
Stack: [e.g., Next.js App Router + TypeScript + Supabase]
Existing structure: [path/to/component or API]
Constraints:
- Follow project conventions (naming, exports, types, styling).
- Do not add new dependencies.
- Use async/await + proper error handling.

Acceptance Criteria:
- [Condition 1: must compile]
- [Condition 2: must match TypeScript interface]
- [Condition 3: must pass tests or example input]

You can extend this with Schema, UI Layout, Database Model, or API Contract sections as needed.

â¸»

5) Typical Use Cases for Opus 4.1

Category	Example Request	Opus Task
Frontend Dev	â€œAdd dark mode toggle to navbar.â€	Generates component logic, Tailwind classes, and persists theme in localStorage.
Backend/API	â€œCreate POST /users route with validation.â€	Writes Express/Supabase endpoint and returns typed JSON responses.
Database Schema	â€œDesign table for user messages with indexing.â€	Outputs SQL + Supabase migration.
Testing	â€œAdd Jest test for registerUser function.â€	Writes mock + assertions with 100% branch coverage.
Docs/Readme	â€œDocument API endpoints and usage examples.â€	Produces Markdown reference with sample payloads.
Refactor	â€œSplit utils.ts into separate modules by domain.â€	Performs clean modularization while keeping tests green.
Performance	â€œOptimize image loader for Next.js.â€	Suggests next/image usage or lazy loading techniques.


â¸»

6) Communication Patterns

âœ… DO:
	â€¢	Give Opus specific constraints: â€œuse Tailwind only,â€ â€œdo not modify schema,â€ â€œreturn React.FC only.â€
	â€¢	Ask for structured output: â€œreturn JSON schema + explanation.â€
	â€¢	Reference your standards: â€œFollow React Component Development Standards.â€
	â€¢	Validate after each major generation.

âŒ DONâ€™T:
	â€¢	Say â€œbuild the full app from scratchâ€ (too broad).
	â€¢	Mix design, logic, and backend requests in one prompt.
	â€¢	Skip review or testing; Opus assumes youâ€™ll verify.

â¸»

7) Debugging & Fixes

When something breaks, provide:

Error:
[Paste the exact error log or stack trace]

Expected:
[Describe what should have happened]

Fix Scope:
- Modify only X file
- Keep types/interfaces intact
- Do not reformat unrelated sections

Then ask:

â€œExplain the cause and produce a minimal fix.â€

Opus 4.1 will analyze logs and propose the smallest safe patch.

â¸»

8) Integrating With Development Tools

Tool	How Opus Helps
VS Code / Cursor	Inline edits (/edit), diff previews, quickfix explanations.
Git / Source Control	Generate commit messages, summarize PRs, or document changes.
CI/CD	Write YAML pipelines, test workflows, and deployment checks.
Supabase	Generate SQL migrations, policies, RLS, and API routes.
Next.js	Generate routes, layouts, Server Actions, and typed data fetching.
Tailwind	Suggest responsive class sets, animations, or accessibility improvements.


â¸»

9) Reviewing Opus 4.1 Output

After every generation:
	â€¢	Check file boundaries: Did it add extra files? Should they exist?
	â€¢	Confirm import paths: Opus may assume shorter paths â€” fix to absolute or alias-based imports.
	â€¢	Validate types: Run tsc --noEmit to ensure no type regressions.
	â€¢	Run tests: Ensure no snapshot or regression failures.
	â€¢	Read console logs: Opus is literal; if you leave debug code, itâ€™ll propagate.

â¸»

10) Security & Privacy
	â€¢	Never share real credentials, database URLs, or tokens in prompts.
	â€¢	If debugging auth or API errors, redact keys and user data.
	â€¢	For production code, always manually review any AI-written auth or encryption logic.
	â€¢	When generating SQL or shell commands, review for injection or destructive queries before executing.

â¸»

11) Best Practices Checklist

âœ… Start with a clear spec (Goal, Context, Constraints).
âœ… Use incremental prompting â€” one feature or fix per session.
âœ… Always review the diff before applying.
âœ… Keep a .opusrules file per project.
âœ… Ask for tests, types, and docs â€” every time.
âœ… Run lint + typecheck + test after acceptance.
âœ… Save prompt + output for traceability (in /docs/prompts/).

â¸»

12) Example .opusrules for Multi-stack Projects

# Opus 4.1 Rules (Full-stack Project)

Stack: Next.js App Router + TypeScript + Supabase + Tailwind

Frontend
- Use Server Components by default.
- Use 'use client' only when interactive.
- Always define interface above component.
- Maintain dark/light theme parity.
- Use className with clsx or cva for conditional styling.

Backend
- All DB access through Supabase client.
- Write RLS-safe SQL.
- No direct string concatenation for queries.

Testing
- Use Vitest for components, Jest for backend.
- Coverage â‰¥ 80%.

General
- Keep responses modular.
- Comment major logic blocks.
- Avoid any, as unknown as, and unsafe casts.
- Write docstrings for exported functions.


â¸»

13) Troubleshooting Common Issues

Symptom	Likely Cause	Fix
Opus repeats explanations	Ask â€œReturn only code blocks.â€	
Generates extra dependencies	Add â€œDo not import new packages.â€	
Breaks schema relationships	Say â€œModify logic only; do not alter schema.â€	
Broad rewrites	Use smaller context or highlight specific section.	
Wrong file assumptions	Provide the exact relative path + brief file summary.	


â¸»

14) Extending Opus for Team Use
	â€¢	Centralize reusable prompts in /docs/prompts/.
	â€¢	Create project templates (Next.js starter, API boilerplate).
	â€¢	Define linting/tests as â€œAI-acceptance criteria.â€
	â€¢	Use Opusâ€™s conversation export or repository context sharing for handoffs.

â¸»

15) Summary Checklist

âœ… Define .opusrules
âœ… Plan > Edit > Test > Review cycle
âœ… Give stack + style constraints
âœ… Validate every output
âœ… Run build + tests before merge
âœ… No secrets in chat
âœ… Archive accepted prompts for documentation
-----------------------------------------------------------------------------------------------------
Sonnet 4.5 Development Standards

(General-Purpose Reference for All Project Types)

â¸»

1ï¸âƒ£ Core Philosophy
	â€¢	Human defines intent; Sonnet expands it with precision.
You remain the product owner â€” Sonnet executes, explains, and optimizes.
	â€¢	Balance reasoning and code. Sonnet 4.5 is strongest when you give it both logic and purpose (e.g., â€œwhyâ€ this function exists).
	â€¢	Iterative, verifiable progress. Treat Sonnet sessions like commits: small, reversible, reviewable.
	â€¢	Clarity > Cleverness. The clearer your direction, the higher the quality of Sonnetâ€™s structured output.
	â€¢	Always pair output with validation. Require tests, examples, or schema verification.

â¸»

2ï¸âƒ£ Project Setup

When integrating Sonnet 4.5 into your workflow or IDE (Cursor, VS Code, Web-based workspace, or API):

Recommended repo additions

/docs/Sonnet-Standards.md
/.sonnetrules              # Behavioral & safety constraints
/docs/prompts/             # Reusable Sonnet prompt blueprints
/tests/                    # Validation scripts for Sonnet-generated code

.sonnetrules template

# Sonnet 4.5 Rules

## Language & Stack
- Primary: TypeScript, Python, or Go.
- Frontend: React + Tailwind + Next.js (App Router).
- Backend: Supabase / Express / FastAPI depending on project.
- Databases: Postgres preferred; enforce parameterized queries.
- Styling: Tailwind + clsx/cva patterns.

## Output Discipline
- Never modify unrelated lines.
- Keep responses modular; 1 logical change per snippet.
- Include types/interfaces for all new code.
- No new dependencies unless justified and minimal.

## Reasoning Clarity
- Explain logic only when requested.
- Favor explicit control flow over magic abstractions.
- Include docstrings for complex functions or classes.

## Safety
- Never reveal or use secrets.
- Validate user inputs; treat all external data as untrusted.

## Behavior
- Respect repo conventions.
- Follow Prettier, ESLint, Tailwind, and TypeScript standards.
- Generate tests whenever you generate logic.


â¸»

3ï¸âƒ£ How to Collaborate With Sonnet 4.5

A. Structured Prompt Framework

Use the 4C method: Context â†’ Constraints â†’ Criteria â†’ Check

Context:
Weâ€™re building a user authentication API using Supabase.

Constraints:
TypeScript strict; use named exports; return standardized JSON responses.

Criteria:
Must handle sign-in, sign-up, and password reset flows.

Check:
Output must compile, follow project conventions, and include example API calls.

B. Ideal Session Workflow

Step	Action	Description
1. Plan	Explain the goal & outline subtasks	â€œPlan the database and API endpoints for user messaging.â€
2. Generate	Request one file/feature at a time	â€œGenerate messages API route handler.â€
3. Validate	Run or reason-check	â€œAdd Jest/Vitest tests for this route.â€
4. Refine	Ask for improvements	â€œRefactor using async/await and add logging middleware.â€
5. Document	Request docs/readme	â€œDocument how to extend the message schema.â€

C. Feedback Style
	â€¢	Direct commands â†’ predictable output (â€œAdd loading state to ChatPanel.tsx.â€)
	â€¢	High-level goals â†’ multi-file proposals (â€œDesign architecture for offline caching.â€)
	â€¢	Combine both for large systems: â€œPlan entire feature; implement only X part.â€

â¸»

4ï¸âƒ£ Prompt Templates

ğŸ§  Feature Implementation

Goal:
Add [feature] using [stack].

Context:
Existing structure [file paths]; connected to [API/db/etc].

Constraints:
- No new dependencies.
- Follow TypeScript + Tailwind + React guidelines.
- Keep code modular.

Acceptance:
- Compiles successfully
- Passes provided test or example input
- Follows established code style

ğŸ”„ Refactor / Optimization

Refactor this module for readability and performance.
Keep the API surface identical.
Do not change variable names, logic flow, or exports unless necessary.
Add inline comments summarizing major logic changes.

âœ… Testing / Validation

Write comprehensive tests for this module.
- Cover success, failure, and edge cases.
- Use Jest or Vitest.
- Include mocks for network requests.

ğŸ“˜ Documentation / Explanation

Explain this codebase in concise, structured documentation.
Include purpose, setup instructions, and extension examples.
Use Markdown formatting and headings.


â¸»

5ï¸âƒ£ Ideal Output Formats

Sonnet 4.5 responds best when you specify the desired output format:

Goal	Format Example
Code	â€œReturn only code in one fenced block (```ts).â€
Architecture	â€œReturn bullet list of folders + description.â€
Docs	â€œReturn Markdown sections: Overview, Setup, Usage.â€
Tests	â€œReturn test file with Jest syntax only.â€
SQL	â€œReturn SQL migration; no prose.â€


â¸»

6ï¸âƒ£ Integration With Tools

Tool	How Sonnet 4.5 Fits
Cursor / VS Code	Inline /edit or Chat for diffs, error explanations, or test generation.
Next.js Projects	Generate routes, layouts, and Server Actions; type-safe data fetching.
Supabase	Write SQL policies, RLS, and JS client logic.
Tailwind	Suggest class structures, responsive layouts, and animation utilities.
TypeScript	Strengthen type safety; refactor to generics; explain compile errors.
Git	Summarize PRs or auto-generate commit messages.
CI/CD	Generate workflows, deployment YAML, and environment checks.


â¸»

7ï¸âƒ£ Review Checklist

After each Sonnet output:

âœ… Read the diff â€” ensure no unrelated changes.
âœ… Run typecheck/lint/test.
âœ… Review logic â€” verify security, input validation, data flow.
âœ… Check compliance â€” does it align with .sonnetrules?
âœ… Document the change (why + how).

â¸»

8ï¸âƒ£ Security & Ethics
	â€¢	Treat Sonnetâ€™s workspace as public â€” redact secrets or PII.
	â€¢	Review all generated SQL or shell commands before execution.
	â€¢	For authentication, encryption, or payment flows, always manually verify logic.
	â€¢	Use dependency pinning (^ â†’ exact versions) in generated configs.

â¸»

9ï¸âƒ£ Anti-Patterns (Avoid These)

Anti-Pattern	Why Itâ€™s Risky	Preferred Fix
â€œBuild my whole app.â€	Too broad; weak context fidelity.	Break into modules.
Large unreviewed diffs	Hard to trace regressions.	Generate small atomic patches.
Excessive dependencies	Security & size issues.	Use existing libs/utilities.
Ignoring type errors	Causes runtime bugs.	Fix TS warnings before continuing.
Missing validation	Unsafe inputs.	Always validate with Zod/Yup/schema.


â¸»

ğŸ”Ÿ Performance & Scalability
	â€¢	Prefer modular outputs â†’ easier caching and test coverage.
	â€¢	Use Sonnet 4.5â€™s reasoning ability to analyze performance hotspots before rewriting code.
	â€¢	Request complexity notes:
â€œExplain time & space complexity of this algorithm in Big-O notation.â€
	â€¢	Ask for optimization examples:
â€œSuggest faster alternative for this data transform; keep functional style.â€

â¸»

11ï¸âƒ£ Example Full Workflow

Goal: Add image upload to user profiles.

Steps:
1ï¸âƒ£ â€œPlan schema and API for image uploads.â€
2ï¸âƒ£ â€œImplement only Supabase Storage handler.â€
3ï¸âƒ£ â€œIntegrate handler in UserProfile.tsx.â€
4ï¸âƒ£ â€œWrite test for upload success/failure.â€
5ï¸âƒ£ â€œDocument how to change bucket name later.â€

Review:
	â€¢	Code builds â†’ âœ…
	â€¢	Type safety â†’ âœ…
	â€¢	Upload policy validated â†’ âœ…
	â€¢	Docs committed â†’ âœ…

â¸»

12ï¸âƒ£ Troubleshooting Cheatsheet

Issue	Likely Cause	Solution
Sonnet loops on explanation	Add â€œReturn only code, no prose.â€	
Unwanted deps	Say â€œDo not import new packages.â€	
Context loss	Re-provide relevant files or .sonnetrules summary.	
Wrong style	Reference your React/Tailwind standards directly.	
Security holes	Re-prompt: â€œRe-audit for auth and input safety.â€	


â¸»

13ï¸âƒ£ Cross-Reference With Your Stack Standards

When Sonnet 4.5 writes or reviews code, it should follow:
	â€¢	ğŸ§© React Component Development Standards
	â€¢	ğŸŒ Next.js App Router Patterns
	â€¢	ğŸ¨ Tailwind CSS Usage Guidelines
	â€¢	ğŸ§  TypeScript Development Standards
	â€¢	âš™ VS Code Development Standards
	â€¢	ğŸ§° Cursor Development Standards
	â€¢	ğŸ—„ Supabase Development Standards
	â€¢	ğŸ¤– Opus 4.1 Development Standards

Include short reminders or links to these docs in your .sonnetrules for cohesive AI behavior.

â¸»

14ï¸âƒ£ Summary Checklist

âœ… .sonnetrules in repo root
âœ… Clear prompts with context + constraints
âœ… Small, reviewable diffs
âœ… Test + typecheck each output
âœ… Reference stack-specific standards
âœ… No secrets or PII in prompts
âœ… Archive approved prompts under /docs/prompts/
---------------------------------------------------------------------------------------------------------------
GPT-5 Development Standards

(General-Purpose Professional Reference)

â¸»

1ï¸âƒ£ Core Philosophy
	â€¢	GPT-5 = Reasoning Engine + Execution Partner.
Itâ€™s not just a text generator â€” itâ€™s a structured problem-solver capable of full-stack reasoning, architectural planning, and contextual refinement.
	â€¢	Human intent is the system prompt.
You define goals, scope, and acceptance criteria. GPT-5 builds around those.
	â€¢	Iterative over generative.
Use GPT-5 as a looped assistant â€” plan, generate, test, and refine â€” not a one-shot coder.
	â€¢	Determinism first.
Ask for explicit structure, typed outputs, and validation logic.

â¸»

2ï¸âƒ£ Recommended Project Setup

Keep your repository and workspace GPT-5-friendly:

/docs/GPT5-Standards.md      # This document
/.gptrules                   # Behavioral constraints & formatting rules
/docs/prompts/               # Prompt blueprints (feature, refactor, test)
.tests/                      # AI validation or generated unit tests

.gptrules Template

# GPT-5 Rules

## Languages & Frameworks
- Use TypeScript or Python where possible.
- Frontend: React + TailwindCSS + Next.js App Router.
- Backend: Supabase / Express / FastAPI.
- Database: Postgres (strict RLS).
- Infrastructure: Docker, GitHub Actions, or Vercel.

## Code Behavior
- Never modify unrelated lines.
- Respect existing exports, types, and interfaces.
- Output only complete code blocks, not partial fragments.
- Avoid installing new dependencies unless justified.
- Follow file naming (PascalCase for components, camelCase for functions).

## Reasoning Discipline
- Always describe reasoning if logic is non-trivial.
- Use explicit variable names; avoid â€œmagicâ€ behavior.
- Include comments for async or complex control flow.

## Safety & Privacy
- No secrets or keys in code or text.
- Treat user data as untrusted.
- Validate inputs server-side.

## Output Formatting
- Prefer Markdown fenced code blocks.
- Use clear section headings.
- Keep documentation structured (Overview â†’ Setup â†’ Usage â†’ Examples).


â¸»

3ï¸âƒ£ Working With GPT-5

A. The 3-Layer Prompt Model

Layer	Purpose	Example
Intent	What you want done	â€œBuild a REST endpoint for user signup.â€
Context	What GPT-5 should know	â€œWeâ€™re using Supabase + Next.js App Router.â€
Constraints	What must stay true	â€œUse TypeScript strict mode; no new libraries.â€

â¡ Always provide acceptance criteria:

â€œMust compile, pass unit tests, and match coding conventions.â€

â¸»

B. Workflow Pattern

1ï¸âƒ£ Plan â€“ Ask GPT-5 to outline architecture, files, or schema.
2ï¸âƒ£ Implement â€“ Request one module or file at a time.
3ï¸âƒ£ Validate â€“ Ask GPT-5 to generate or explain tests.
4ï¸âƒ£ Refactor â€“ Improve structure, not behavior.
5ï¸âƒ£ Document â€“ Generate clear Markdown usage notes.

â¸»

C. Effective Command Types

Type	Example	Expected Output
Generate	â€œImplement a user profile card using Tailwind.â€	React component code
Explain	â€œDescribe the data flow between backend and frontend.â€	Diagram or textual flow
Refactor	â€œOptimize this query to reduce load time.â€	Cleaned SQL or JS logic
Test	â€œAdd Jest tests for message API.â€	Complete test file
Document	â€œCreate setup instructions for new devs.â€	Markdown guide


â¸»

4ï¸âƒ£ Prompt Templates

ğŸ”§ Feature Implementation

Goal:
Add [feature] using [tech stack].

Context:
Existing project with [framework/library]; follows [naming convention].

Constraints:
- Do not modify unrelated files.
- Follow .gptrules conventions.
- Keep all types explicit.
- Return complete file content.

Acceptance:
- Compiles and runs successfully.
- Includes prop/interface definitions.
- Adheres to style and accessibility standards.

ğŸ§© Refactor / Improve

Refactor this file for clarity and performance.
Keep public API and behavior identical.
Add comments explaining key logic decisions.
Do not add dependencies.

ğŸ§ª Testing

Generate comprehensive tests for this module:
- Use Jest or Vitest.
- Cover success, failure, and edge cases.
- Include mock data where necessary.

ğŸ“– Documentation

Write a concise README section for this module.
Include Overview, Setup, Usage, and Extension steps.
Use Markdown formatting.


â¸»

5ï¸âƒ£ Ideal Output Conventions

Type	GPT-5 Output Format
Code	Fenced block (ts, js, ```py)
Docs	Markdown with headings
Config	Complete JSON/YAML object
Diff	Unified diff format (+ / -)
Explanation	Bullet points + short summary


â¸»

6ï¸âƒ£ Multi-Stack Integration

Area	GPT-5 Role
Frontend	Builds React components, UI flows, and accessibility logic.
Backend	Generates APIs, database handlers, and schema migrations.
Database	Writes optimized SQL, RLS, and indexing strategies.
DevOps	Creates CI/CD configs (GitHub Actions, Docker).
Testing	Produces unit/integration tests.
Docs	Writes technical documentation and changelogs.
UX	Suggests microcopy, placeholders, and content tone.


â¸»

7ï¸âƒ£ Validation Checklist

After GPT-5 output:

âœ… Code compiles / lints cleanly
âœ… Tests run successfully
âœ… No any or unsafe casts
âœ… Schema matches expectations
âœ… Docs are readable and Markdown-formatted
âœ… Follows conventions (naming, imports, Tailwind usage)

â¸»

8ï¸âƒ£ Security & Compliance
	â€¢	Never expose .env or API credentials in prompts.
	â€¢	Validate authentication flows manually.
	â€¢	Check all generated SQL for injection safety.
	â€¢	Run dependency audits (npm audit or pip check).
	â€¢	Review cloud configurations for least-privilege access.

â¸»

9ï¸âƒ£ Debugging & Repair Prompts

Problem	Debug Prompt
Type errors	â€œFix only the TypeScript type errors shown in this log.â€
API mismatch	â€œAlign request/response format with existing handler.â€
Performance issue	â€œAnalyze and optimize time complexity; keep same output.â€
Security issue	â€œHarden this endpoint against unauthorized access.â€
Lint violations	â€œMake minimal changes to satisfy ESLint rules.â€


â¸»

ğŸ”Ÿ Collaboration Patterns

When pairing GPT-5 with other AI agents (like Cursor, Opus, or Sonnet):

Role	GPT-5 Strength
Planner (Opus)	GPT-5 executes Opusâ€™s architectural plans.
Reasoner (Sonnet)	GPT-5 applies Sonnetâ€™s analysis to concrete implementation.
Coder (Cursor)	GPT-5 reviews Cursorâ€™s code for logic consistency.
Tester (VS Code)	GPT-5 writes tests or fixes failing cases inside VS Code.


â¸»

11ï¸âƒ£ Anti-Patterns

ğŸš« â€œBuild the entire app end-to-end in one go.â€
ğŸš« â€œRewrite all files.â€
ğŸš« â€œSkip validation or tests.â€
ğŸš« â€œAdd random libraries.â€
ğŸš« â€œMix code + prose + explanations in the same output.â€

âœ… Always specify the scope and format.
âœ… Always review before commit.

â¸»

12ï¸âƒ£ Example Complete Workflow

Goal: Add comment threads to posts.

1ï¸âƒ£ â€œPlan schema and API endpoints for threaded comments.â€
2ï¸âƒ£ â€œGenerate comments.ts API route using Supabase.â€
3ï¸âƒ£ â€œAdd client hook useComments().â€
4ï¸âƒ£ â€œWrite Jest tests for posting and deleting comments.â€
5ï¸âƒ£ â€œDocument in README under â€˜User Interactionsâ€™.â€

âœ… Review + test â†’ âœ… Commit â†’ âœ… Deploy.

â¸»

13ï¸âƒ£ Troubleshooting

Issue	Cause	Fix
GPT-5 over-explains	Add â€œReturn only code.â€	
Inconsistent naming	Re-prompt with naming convention.	
Missed constraints	Restate .gptrules file summary.	
Context loss	Re-upload related file content or schema.	
Security holes	Ask â€œReview for vulnerabilities and fix.â€	


â¸»

14ï¸âƒ£ Cross-References

When GPT-5 generates code, it should comply with:
	â€¢	ğŸ§© React Component Standards
	â€¢	ğŸŒ Next.js App Router Patterns
	â€¢	ğŸ¨ Tailwind CSS Guidelines
	â€¢	ğŸ§  TypeScript Rules
	â€¢	âš™ VS Code Standards
	â€¢	ğŸ¤– Cursor Development Standards
	â€¢	ğŸ§¬ Supabase Policies
	â€¢	ğŸ¼ Opus 4.1 Standards
	â€¢	ğŸ§© Sonnet 4.5 Standards

â¸»

15ï¸âƒ£ Summary Checklist

âœ… .gptrules file in root
âœ… Specific, contextual prompts
âœ… Small, testable outputs
âœ… Type safety and linting enforced
âœ… No secrets or dependencies added
âœ… All outputs documented
âœ… Tests auto-generated when possible
âœ… Human review before merge
-------------------------------------------------------------------------------------------------------------
ğŸ’– Lovable Development Standards

(General-Purpose Full-Stack Design & Build Guidelines)

â¸»

1ï¸âƒ£ Core Philosophy
	â€¢	Lovable = Human Intent â†’ Product Reality.
You describe what you want, Lovable generates production-grade, full-stack code.
	â€¢	Precision over Poetry.
The clearer your prompt and acceptance criteria, the smarter and cleaner the app Lovable builds.
	â€¢	One build = one clear scope.
Donâ€™t overload a Lovable app with multiple complex features. Instead, build modular, composable apps that integrate cleanly later.
	â€¢	AI is your engineer, not your boss.
You define architecture, roles, and data flow. Lovable executes.

â¸»

2ï¸âƒ£ Project Setup

Organize your Lovable workspace and repos with consistent structure:

ğŸ“ Lovable Projects
 â”£ ğŸ’¬ Chat App (Realtime Messaging)
 â”£ ğŸ“š Book Tracker (Quotes & OCR)
 â”£ ğŸ¬ ClipCaption (AI Video Metadata)
 â”£ ğŸ§­ Portfolio (Marketing & Landing)
 â”— ğŸ§© Shared Components & Templates

Folder Rules (within each app)

/components     â†’ UI building blocks (Buttons, Cards, Modals)
/pages          â†’ Route screens or main app views
/lib or /utils  â†’ Helpers, constants, or logic functions
/styles         â†’ Tailwind or global stylesheets
/api            â†’ Endpoints or external integrations
/supabase       â†’ Auth, RLS, and storage setup
/docs           â†’ Architecture, prompt specs, and changelogs


â¸»

3ï¸âƒ£ Prompt Design Standards

ğŸ§  The Golden Prompt Pattern

Goal:
Describe in 1â€“2 sentences what the app should accomplish.

Features:
List the key features as bullet points, focusing on user actions.

Design:
Specify visual layout, navigation flow, and theme (light/dark, gradient, minimal).

Backend:
Mention integrations (Supabase, Firebase, Stripe, etc.) and any authentication or database models.

Rules:
Define coding preferences, naming, or architectural standards (TypeScript, Tailwind, Next.js App Router, RLS).

Acceptance Criteria:
- App loads and builds with no errors.
- Features perform exactly as described.
- Follows React/Tailwind/TypeScript standards.
- Responsive and accessible UI.

âœ… Example

Goal: Build a realtime chat app like Messenger.
Features:
- Message send, edit, delete (within 10 minutes)
- Message status (âœ“ sent, âœ“âœ“ delivered, âœ“âœ“ blue = read)
- Image uploads with preview
- Block users, mute conversations, search messages
- Notifications and pinned messages

Backend: Supabase (auth + RLS + storage)
Frontend: React + Tailwind + Zustand for state
Rules: 
- Follow my React Component & Next.js standards
- Use useReducer for complex local state
- Use Tailwind classes via className
Acceptance: 
- Fully responsive, modern UI
- Realtime message sync via Supabase channel


â¸»

4ï¸âƒ£ Build Process

ğŸ’¡ Plan Phase
	â€¢	Define exact features before clicking Build with AI.
	â€¢	Keep each build to one major module (e.g., Chat, Profile, Admin Panel).
	â€¢	If building a system, plan your module hierarchy in /docs/architecture.md.

ğŸ— Build Phase
	â€¢	Use structured, numbered prompts.
	â€¢	Include all dependencies, libraries, and backend connections.
	â€¢	Specify UI sections clearly (Navbar, Hero, Feed, Sidebar, Footer).

ğŸ§ª Review Phase
	â€¢	After each build, open the code view:
	â€¢	Check components folder â†’ consistency, props typing.
	â€¢	Check Supabase config â†’ policies, auth usage.
	â€¢	Check state management â†’ hooks and stores are properly scoped.
	â€¢	Fix RLS conflicts early if using Supabase.

ğŸš€ Deploy Phase
	â€¢	Use Lovableâ€™s deploy button or export to Vercel, Netlify, or Supabase Edge.
	â€¢	Always test the deployed version before sharing.

â¸»

5ï¸âƒ£ Data & Backend Guidelines

ğŸ—„ Database
	â€¢	Use Supabase or Firebase as backend.
	â€¢	Define all schemas in your /docs/schema.sql or /supabase/migrations.sql.
	â€¢	Apply RLS (Row Level Security) policies early â€” before connecting the front end.

ğŸ” Authentication
	â€¢	Use Supabase Auth or OAuth2 (Google, GitHub).
	â€¢	Store only necessary user metadata (id, username, avatar_url).
	â€¢	Protect sensitive queries with server-side actions.

ğŸ“¦ Storage
	â€¢	Use Supabase storage for images or documents.
	â€¢	Enforce bucket-level RLS for secure user folders.
	â€¢	Compress uploads (â‰¤5MB for images).

â¸»

6ï¸âƒ£ Frontend UI/UX Standards
	â€¢	Follow your React Component Standards and Tailwind Guidelines.
	â€¢	Use consistent structure:

interface Props { title: string; image?: string; }
export const Card: React.FC<Props> = ({ title, image }) => (
  <div className="rounded-lg border p-4 shadow-sm">
    <img src={image} alt="" className="rounded-md mb-2" />
    <h2 className="text-lg font-semibold">{title}</h2>
  </div>
);


	â€¢	Keep all components accessible:
	â€¢	Use semantic HTML (<button>, <label>, <input>).
	â€¢	Use ARIA attributes where needed.
	â€¢	Follow the 8px grid system for spacing consistency.

â¸»

7ï¸âƒ£ Styling & Theming
	â€¢	Use TailwindCSS via className for speed and scalability.
	â€¢	For variants, use clsx or cva:

const button = cva('px-4 py-2 rounded font-medium', {
  variants: {
    intent: {
      primary: 'bg-blue-600 text-white hover:bg-blue-700',
      ghost: 'bg-transparent hover:bg-gray-100'
    },
  },
  defaultVariants: { intent: 'primary' },
});


	â€¢	Store global color tokens in tailwind.config.js.
	â€¢	Ensure color contrast passes accessibility tests.
	â€¢	Match your Figma design tokens for perfect devâ€“design parity.

â¸»

8ï¸âƒ£ Testing & QA

Checkpoint	What to Verify
âœ… Build Integrity	No errors, missing imports, or invalid props
âœ… Responsiveness	Works on mobile/tablet/desktop
âœ… Accessibility	Proper contrast, focus states, ARIA
âœ… State Sync	Supabase Realtime events flow correctly
âœ… Database Security	RLS properly applied, no overexposed tables
âœ… UI Consistency	Matches Figma or Canva mockups
âœ… Deployment	Hosted version runs without console errors


â¸»

9ï¸âƒ£ Common Lovable Pitfalls

Issue	Cause	Solution
â€œApp fails to loadâ€	Misconfigured Supabase URL or anon key	Check .env in project settings
â€œUsers can see othersâ€™ dataâ€	Missing RLS or faulty policy	Review pg_policies and test with auth.uid()
â€œUI looks offâ€	Tailwind class mismatch	Sync tailwind.config.js with Lovableâ€™s config
â€œRealtime not workingâ€	Publication missing in DB	Run ALTER PUBLICATION supabase_realtime ADD TABLE table_name;
â€œBuild overwrote changesâ€	Rebuilt app without exporting	Always export code after successful build


â¸»

ğŸ”Ÿ Collaboration & Versioning
	â€¢	Export code from Lovable after each build to a Git repo.
	â€¢	Commit generated code with message:

feat: [feature-name] initial build (Lovable AI)


	â€¢	Add changelog in /docs/changelog.md after each iteration.
	â€¢	Store prompt history in /docs/prompts/.
	â€¢	Collaborate via GitHub or Lovableâ€™s team-sharing interface.

â¸»

11ï¸âƒ£ AI Prompt Hygiene

DO:
	â€¢	Use short, structured sentences.
	â€¢	Reference previous build versions.
	â€¢	Provide visual direction (e.g., â€œ3-column grid feed like Twitterâ€).
	â€¢	Include backend context (Supabase schema, auth flow).

DONâ€™T:
	â€¢	Mix multiple feature requests.
	â€¢	Use vague adjectives (â€œmodernâ€, â€œcoolâ€, â€œbeautifulâ€).
	â€¢	Forget acceptance criteria.
	â€¢	Skip reviewing RLS or Supabase policies before testing.

â¸»

12ï¸âƒ£ Integration with Your Stack

Lovable apps should align with your entire ecosystem:

Stack	Integration Purpose
Next.js	SSR/CSR hybrid routing
Supabase	Database + auth + file storage
Tailwind	UI styling and responsive design
TypeScript	Type safety across components
Figma	Design reference and visual parity
Canva	Marketing visuals and branding
Cursor / VS Code	Local testing and manual patching
GPT-5 / Opus / Sonnet	Refactoring, documentation, logic optimization


â¸»

13ï¸âƒ£ Best Practices for Longevity
	â€¢	Keep builds modular â†’ separate apps for admin, dashboard, and user front end.
	â€¢	Regularly export code to avoid accidental overwrite.
	â€¢	Maintain a /docs/prompt-spec.md log for reproducibility.
	â€¢	Use Lovableâ€™s API integrations (Stripe, Supabase) directly instead of embedding secret keys.
	â€¢	Audit generated code for dependency drift.
	â€¢	Use GitHub Actions or CI/CD to test Lovable exports automatically.

â¸»

14ï¸âƒ£ Cross-Reference

Ensure all Lovable builds follow:
	â€¢	ğŸ§© React Component Development Standards
	â€¢	ğŸŒ Next.js App Router Patterns
	â€¢	ğŸ¨ Tailwind CSS Usage Guidelines
	â€¢	ğŸ§  TypeScript Development Standards
	â€¢	âš™ VS Code / Cursor Standards
	â€¢	ğŸ—„ Supabase Policies & RLS Guidelines
	â€¢	ğŸ¨ Figma & Canva Design Standards
	â€¢	ğŸ¤– Opus 4.1 / Sonnet 4.5 / GPT-5 AI Standards

â¸»

15ï¸âƒ£ Final Review Checklist

âœ… Prompt written with clear features and backend context
âœ… Build compiles and deploys cleanly
âœ… Supabase auth and RLS confirmed
âœ… Components match Tailwind and Figma design
âœ… Data syncing tested across devices
âœ… Accessibility validated
âœ… Code exported and versioned
âœ… Documentation updated in /docs/
-----------------------------------------------------------------------------------------------------------
ğŸ§­ Base44 System Standards

(General-Purpose Professional Framework for Design, Development, and Collaboration)

â¸»

1ï¸âƒ£ Core Philosophy
	â€¢	Base44 = Foundation + Harmony + Scale.
The system connects design, code, and communication into one continuous creative process â€” from concept to deployment.
	â€¢	Four Pillars x Four Dimensions â†’ â€œ44.â€
	â€¢	Pillars: Design â€¢ Development â€¢ Documentation â€¢ Delivery
	â€¢	Dimensions: Visual â€¢ Structural â€¢ Behavioral â€¢ Experiential
	â€¢	The goal: to keep all layers (UI, UX, logic, data, and story) consistent, scalable, and understandable by humans and machines.
	â€¢	Everything is a component.
Whether itâ€™s a UI block, SQL schema, or marketing visual â€” it should be reusable, documented, and version-controlled.

â¸»

2ï¸âƒ£ The Base44 Architecture

The Base44 system organizes your product lifecycle into four operational layers:

Layer	Purpose	Tools / Examples
1. Design Layer	Establishes visual, interaction, and brand consistency.	Figma, Canva, Color Tokens, Layout Grids
2. Code Layer	Implements logic and infrastructure with strong typing and RLS.	Next.js, React, TypeScript, Supabase
3. Documentation Layer	Explains, visualizes, and maintains context.	Markdown Docs, Storybook, Notion, Git README
4. Delivery Layer	Deploys and monitors the experience at scale.	Vercel, GitHub Actions, Docker, CI/CD Pipelines

All four layers communicate through shared tokens, rules, and version history.

â¸»

3ï¸âƒ£ Base44 Naming & Structure Rules

Folder Hierarchy (Unified)

/base44
 â”£ /design          # Brand kits, Figma exports, Canva assets
 â”£ /frontend        # React / Next.js code
 â”£ /backend         # Supabase / API / Scripts
 â”£ /docs            # Markdown guides and reference files
 â”£ /automation      # Workflows, Actions, scripts
 â”— /archive         # Old versions and deprecated assets

Naming Convention

Type	Example
Components	ButtonPrimary.tsx
API Routes	/api/users/create.ts
DB Tables	user_profiles, chat_messages
Figma Frames	UI/Button/Primary
Canva Files	Base44_Campaign_2025_v2
Docs	Base44-Standards.md

Every asset in Base44 should be identifiable across systems by its name.
If you see ButtonPrimary in Figma, it should exist as ButtonPrimary.tsx in code.

â¸»

4ï¸âƒ£ Design Layer (Visual & Experiential)

ğŸ¨ Visual Tokens

Base44 uses semantic, platform-agnostic tokens that can sync to both Figma and Tailwind:

{
  "color.primary": "hsl(258, 90%, 66%)",
  "color.background.light": "#FFFFFF",
  "font.body": "Inter, sans-serif",
  "radius.md": "0.5rem"
}

âœ Typography
	â€¢	Use 2â€“3 font families max (primary, secondary, mono).
	â€¢	Maintain a consistent hierarchy (H1â€“H6, Body, Caption).
	â€¢	Define typographic scale using modular ratios (1.25Ã— or 1.333Ã—).

ğŸ“ Layout & Grids
	â€¢	Base grid: 8px (multiples only).
	â€¢	Apply Auto Layout in Figma for alignment parity with code.
	â€¢	Establish fluid breakpoints for desktop, tablet, mobile.

ğŸ§© Components
	â€¢	Core elements: Button, Card, Input, Modal, Navbar, Tag.
	â€¢	Use Variants for states (Default, Hover, Active, Disabled).
	â€¢	Align with Tailwindâ€™s spacing and radius system.

ğŸŒ— Themes
	â€¢	Light and dark mode parity required.
	â€¢	All tokens stored as variable pairs (e.g., color.text.light / color.text.dark).

â¸»

5ï¸âƒ£ Code Layer (Functional & Logical)

ğŸ§  Stack Principles
	â€¢	Frontend: Next.js App Router + TypeScript + Tailwind
	â€¢	Backend: Supabase (Postgres + RLS) or Express API
	â€¢	Auth: Supabase Auth or NextAuth.js
	â€¢	State: useReducer (local), Context/Zustand (shared), RLS policies (secure)

ğŸ§± Coding Standards
	â€¢	Use PascalCase for files and components.
	â€¢	Define props via TypeScript interfaces above each component.
	â€¢	Follow import order:

React â†’ External libs â†’ Internal modules â†’ Assets â†’ Styles


	â€¢	Use clsx / cva for conditional styling.
	â€¢	Prefer hooks for side effects and logic encapsulation.

ğŸ” Database & Security
	â€¢	Enforce RLS on all user data tables.
	â€¢	Use policies that follow least privilege.
	â€¢	Never include service keys in the frontend.
	â€¢	Validate all user input via Zod or Supabase RPC functions.

âš™ Automation
	â€¢	Automate linting (eslint), type checks (tsc), and tests (vitest).
	â€¢	Integrate GitHub Actions for CI/CD.
	â€¢	Deploy to staging before production.

â¸»

6ï¸âƒ£ Documentation Layer (Knowledge & Communication)

ğŸ§¾ Docs Hierarchy

/docs
 â”£ Base44-Standards.md
 â”£ React-Component-Standards.md
 â”£ Tailwind-Guidelines.md
 â”£ Supabase-Policies.md
 â”£ TypeScript-Rules.md
 â”— Figma-Design-System.md

ğŸª¶ Style
	â€¢	Markdown first (.md or .mdx).
	â€¢	Use code blocks, headings, and emoji to enhance readability.
	â€¢	Add quick-reference tables for developers.

ğŸ§­ Topics to Document
	â€¢	Project overview
	â€¢	Tech stack and dependencies
	â€¢	Folder conventions
	â€¢	API reference
	â€¢	Common workflows
	â€¢	Design guidelines and links

ğŸ” Versioning
	â€¢	Maintain a version header (v1.0, v1.1, etc.).
	â€¢	Update the changelog at the bottom of every file.
	â€¢	Archive outdated documents in /docs/archive.

â¸»

7ï¸âƒ£ Delivery Layer (Deployment & Scaling)

ğŸš€ Environments
	â€¢	Dev â†’ local builds
	â€¢	Staging â†’ preview testing
	â€¢	Production â†’ live deployment

âš™ Deployment Rules
	â€¢	Use CI/CD pipelines with checks:
	â€¢	Lint
	â€¢	Type validation
	â€¢	Unit + integration tests
	â€¢	Enforce branch protection: main / prod locked.
	â€¢	Deploy via Vercel, Supabase Edge, or Docker Compose.

ğŸ“Š Observability
	â€¢	Monitor via Supabase Logs / Vercel Analytics / PostHog.
	â€¢	Use alerts for failed builds or runtime errors.

â¸»

8ï¸âƒ£ Collaboration Principles

Role	Responsibility
Designers	Maintain brand consistency and design documentation
Developers	Keep code DRY, typed, and in sync with design tokens
Writers/Marketers	Align tone and visuals with brand voice
Reviewers	Perform design QA + code review per PR

Communication Rules
	â€¢	Centralize feedback â†’ Figma comments, PR reviews, or Notion tasks.
	â€¢	Label issues by system layer ([Design], [Docs], [Code], [Deploy]).
	â€¢	Keep PRs atomic (<300 lines).

â¸»

9ï¸âƒ£ AI & Automation Integration

Base44 supports AI tools for productivity:

Tool	Use Case
Cursor / VS Code Copilot	Inline code edits
GPT-5 / Opus / Sonnet	Architecture, code review, test generation
Figma AI / Canva Magic Write	Layouts, image captions
Supabase CLI + Scripts	Automated migrations
Base44 CLI (optional)	Custom setup, deploy, or document generation

AI Prompt Format

Goal:
Implement feature X within Base44 standards.

Context:
Stack: Next.js, Supabase, Tailwind, TypeScript.
Constraints:
No new dependencies. Follow file naming conventions.
Acceptance:
Compiles, tested, documented.


â¸»

ğŸ”Ÿ Brand & Identity Layer

Even if Base44 is a backend or dev system, its visual and voice identity matters:

ğŸ¨ Visual Identity
	â€¢	Base color: hsl(258, 90%, 66%) (Violet)
	â€¢	Secondary: hsl(210, 10%, 20%)
	â€¢	Accent: hsl(45, 100%, 50%)
	â€¢	Font family: â€œInterâ€ (sans-serif)
	â€¢	Logo: minimalist geometric or monospaced â€œ44â€ mark

ğŸ—£ Voice & Tone
	â€¢	Clear, confident, and technically articulate.
	â€¢	Avoid marketing jargon; prefer clarity over complexity.
	â€¢	Write in present tense (â€œBuildâ€, not â€œWe are buildingâ€).

â¸»

11ï¸âƒ£ Accessibility & Inclusivity
	â€¢	WCAG 2.1 AA compliance baseline.
	â€¢	Provide semantic HTML and ARIA labels in components.
	â€¢	Keyboard and screen reader support for all UI.
	â€¢	Use inclusive imagery and neutral color tones.
	â€¢	Accessible documentation with text contrast and heading hierarchy.

â¸»

12ï¸âƒ£ QA & Review Checklist

Category	Questions
Design	Are all UI elements following token rules and spacing?
Code	Are all components typed and linted?
Docs	Is documentation updated and cross-linked?
Security	Are keys, secrets, and RLS policies enforced?
Performance	Any unnecessary rerenders or large assets?
Accessibility	Does color and layout meet accessibility standards?


â¸»

13ï¸âƒ£ Versioning & Maintenance
	â€¢	Tag all releases using semantic versioning (v1.2.0).
	â€¢	Maintain a CHANGELOG.md for visibility.
	â€¢	Review Base44 quarterly to refactor outdated parts.
	â€¢	Use Feature Flags for experimental modules.

â¸»

14ï¸âƒ£ Cross-References

Base44 aligns and integrates with:
	â€¢	âš› React Component Development Standards
	â€¢	ğŸŒ Next.js App Router Patterns
	â€¢	ğŸ¨ Tailwind CSS Guidelines
	â€¢	ğŸ§  TypeScript Standards
	â€¢	ğŸ§° Supabase Policies & SQL Templates
	â€¢	ğŸ¤– Cursor / GPT-5 / Opus / Sonnet Standards
	â€¢	ğŸ§© Figma / Canva Design Standards
	â€¢	âš™ VS Code / Automation Workflows

â¸»

15ï¸âƒ£ Summary Checklist

âœ… Unified directory and naming structure
âœ… Design tokens and code synced
âœ… Type safety and RLS active
âœ… Docs complete and versioned
âœ… Accessible, performant components
âœ… Clear brand identity
âœ… Automated deployment pipeline
âœ… Quarterly refactoring & audits
-----------------------------------------------------------------------------------------------------------------
ğŸ’» Replit Development Standards

(General-Purpose Professional Reference for Coding, Collaboration & Deployment in Replit)

â¸»

1ï¸âƒ£ Core Philosophy
	â€¢	Replit = Code Anywhere, Collaborate Instantly.
The goal is to make programming frictionless â€” from idea to execution â€” using a cloud IDE that runs on any device.
	â€¢	Build â†’ Preview â†’ Share â†’ Deploy.
Every Replit project should be designed to move through these four stages seamlessly.
	â€¢	Focus on reproducibility and clarity.
Your Replit should be understandable and runnable by anyone â€” including teammates, instructors, and future you.

â¸»

2ï¸âƒ£ Workspace Organization

Every Replit project (called a â€œreplâ€) should follow a clean, predictable structure:

ğŸ“ project-name/
 â”£ ğŸ“‚ src/              # Source code
 â”£ ğŸ“‚ public/           # Static assets (images, CSS, HTML)
 â”£ ğŸ“‚ tests/            # Unit and integration tests
 â”£ ğŸ“‚ data/             # JSON, CSV, or SQLite files
 â”£ ğŸ“„ .replit           # Runtime and entrypoint configuration
 â”£ ğŸ“„ replit.nix        # Environment dependencies (for Nix-powered repls)
 â”£ ğŸ“„ package.json      # Node.js projects
 â”£ ğŸ“„ requirements.txt  # Python projects
 â”£ ğŸ“„ README.md         # Documentation / setup notes
 â”— ğŸ“„ main.(py|js|ts|go|rb)  # Entry file

Folder Guidelines
	â€¢	Keep each fileâ€™s purpose obvious.
	â€¢	Group related logic under src/.
	â€¢	Avoid root-level clutter â€” only configuration or entry files belong there.
	â€¢	Use lowercase and hyphens for folder names (book-tracker, not BookTracker).

â¸»

3ï¸âƒ£ Configuration Files

âš™ .replit

Defines how your Replit runs.
Example for Node.js:

run = "npm run dev"
entrypoint = "src/index.js"

Example for Python:

run = "python3 main.py"
language = "python3"

âš™ replit.nix

Specifies packages for Nix-based environments (replacing old â€œ.envâ€ installs).
Example:

{ pkgs }: {
  deps = [
    pkgs.nodejs_20
    pkgs.python311
    pkgs.git
  ];
}


â¸»

4ï¸âƒ£ Environment & Dependencies

ğŸ§© Installing Dependencies
	â€¢	Node.js: npm install express dotenv
	â€¢	Python: pip install flask requests
	â€¢	Rust: cargo add tokio serde
	â€¢	Go: go get github.com/gorilla/mux

Replit automatically detects package.json, requirements.txt, or Cargo.toml and installs dependencies.

ğŸŒ Environment Variables

Set in the â€œSecretsâ€ tab (ğŸ”’ key icon).
Do not hard-code API keys.

Example usage:

const apiKey = process.env.OPENAI_API_KEY;


â¸»

5ï¸âƒ£ Supported Languages & Runtimes

Replit supports 50+ languages. Common use cases:

Language	Ideal For	Run Command
JavaScript / TypeScript	Frontend + backend web apps	npm start
Python	Data science, ML, scripts, APIs	python3 main.py
Go	Backend APIs, CLI tools	go run main.go
C++ / Java	Competitive programming, CS courses	Auto-run
Rust	Systems & backend development	cargo run
HTML/CSS/JS	Static sites	Auto-preview


â¸»

6ï¸âƒ£ UI Features & Tools

ğŸ§­ Sidebar Overview
	â€¢	Files Tab: browse, rename, organize files.
	â€¢	Packages Tab: add or remove dependencies.
	â€¢	Secrets Tab: manage environment variables securely.
	â€¢	Shell Tab: run commands or scripts manually.
	â€¢	Console: view live output or logs.

ğŸ’¬ Multiplayer Mode
	â€¢	Invite teammates for real-time collaboration.
	â€¢	Each collaborator sees their cursor and changes in real time.
	â€¢	Supports pair programming, code review, and live teaching.

âš™ Git Integration
	â€¢	Connect GitHub via the â€œVersion Controlâ€ icon.
	â€¢	Push/pull directly from Replit.
	â€¢	Commit frequently with meaningful messages.

â¸»

7ï¸âƒ£ Project Workflow

ğŸš€ Development Flow
	1.	Plan: Define goals, stack, and folder structure.
	2.	Setup: Install dependencies, configure .replit and replit.nix.
	3.	Code: Write modular, reusable code.
	4.	Test: Use unit tests before deploying.
	5.	Deploy: Use Replit Deployments or external CI/CD.
	6.	Document: Update README.md and version notes.

ğŸ” Version Control
	â€¢	Use branches for new features (feature/chat-module).
	â€¢	Commit descriptive messages:

feat: add chat message model
fix: correct async socket event
docs: update API usage example



â¸»

8ï¸âƒ£ Collaboration & Team Workflow

ğŸ‘¥ Roles

Role	Responsibility
Owner	Controls project settings, billing, and secrets
Editor	Full access to code and console
Commenter	Review and annotate code without editing
Viewer	Read-only access

ğŸ’¬ Review Process
	â€¢	Use comments inline (// TODO: or # FIXME) for context.
	â€¢	For teams, assign feedback using tags (@username).
	â€¢	Record design discussions in a separate NOTES.md file.

â¸»

9ï¸âƒ£ Database & APIs

ğŸ§  Built-In Database

Replit provides a lightweight key-value store:

import { Database } from "@replit/database";
const db = new Database();

await db.set("username", "ahnaf");
const user = await db.get("username");

ğŸ—„ External Databases
	â€¢	Supabase / Firebase â†’ for scalable cloud storage
	â€¢	MongoDB Atlas / PostgreSQL â†’ via API or connection strings
	â€¢	Store credentials in Secrets (DB_URL, SUPABASE_KEY, etc.)

ğŸŒ REST / GraphQL APIs

Replit supports any HTTP client:

const res = await fetch("https://api.openai.com/v1/models", {
  headers: { Authorization: Bearer ${process.env.OPENAI_API_KEY} }
});


â¸»

ğŸ”Ÿ Testing & Debugging

ğŸ§ª Testing Frameworks

Language	Framework
Node.js	Jest / Vitest
Python	Pytest / Unittest
Go	Built-in go test
Rust	Cargo tests

ğŸª² Debugging
	â€¢	Use console.log, print(), or breakpoints via â€œDebugâ€ tab.
	â€¢	Inspect runtime values directly in the console.
	â€¢	Handle exceptions gracefully; never swallow errors silently.

â¸»

11ï¸âƒ£ Deployment & Hosting

âš™ Replit Deployments
	â€¢	Click â€œDeployâ€ â†’ choose environment:
	â€¢	Static Site: HTML/CSS/JS hosted directly.
	â€¢	Web Server: Node, Flask, or Go API runs continuously.
	â€¢	Background Worker: For scripts or bots (Discord, Telegram).
	â€¢	Auto-generates HTTPS URL:

https://project-name.username.repl.co



ğŸŒ External Deployment Options
	â€¢	Export via GitHub â†’ deploy to Vercel, Netlify, or Render.
	â€¢	Use Dockerfile for portable builds.
	â€¢	Deploy APIs to Supabase Edge Functions or Cloudflare Workers if needed.

â¸»

12ï¸âƒ£ Security Standards

âœ… Store credentials in Secrets, not code.
âœ… Use HTTPS for API calls.
âœ… Sanitize user input.
âœ… Limit public access if app uses sensitive data.
âœ… Review dependencies for vulnerabilities.
âœ… Never expose database tokens in logs or URLs.

â¸»

13ï¸âƒ£ Best Practices

Area	Best Practice
File Naming	lowercase-with-dashes (e.g., user-service.js)
Comments	Use JSDoc / docstrings for functions
Code Style	Follow Prettier or ESLint formatting
Performance	Avoid unnecessary loops or re-renders
Accessibility	For web projects, follow WCAG 2.1 AA
Documentation	Always include usage and dependencies in README


â¸»

14ï¸âƒ£ Integrations & Extensions

ğŸ”Œ Useful Integrations

Tool	Purpose
GitHub	Version control and deployment pipeline
Supabase / Firebase	Cloud database and authentication
OpenAI / HuggingFace	AI and NLP capabilities
Discord / Telegram APIs	Bots and chat integrations
Replit Webview	Live previews and embedding apps

ğŸ§  AI Coding Assistants
	â€¢	Replit Ghostwriter â†’ real-time AI code completion
	â€¢	Use it for:
	â€¢	Refactoring
	â€¢	Bug fixes
	â€¢	Generating tests
	â€¢	Code explanation

â¸»

15ï¸âƒ£ Documentation Standards

ğŸ“ README.md Must Include:
	â€¢	Project name & version
	â€¢	Short description
	â€¢	Stack used (Node, Python, etc.)
	â€¢	Setup instructions
	â€¢	Usage examples
	â€¢	API endpoints (if any)
	â€¢	License & credits

Example:

# ChatHub
A full-stack chat app built on Replit using Node.js, Express, and Supabase.

## Setup
1. Clone this repl or fork it.
2. Add your Supabase URL & key in Secrets.
3. Run npm install && npm start.

## Features
- Real-time messaging
- User authentication
- Image upload (Supabase storage)


â¸»

16ï¸âƒ£ Accessibility & Inclusivity
	â€¢	Use semantic HTML in web projects.
	â€¢	Maintain color contrast and alt text for images.
	â€¢	Support keyboard navigation and focus states.
	â€¢	Use inclusive copy (avoid jargon or slang).

â¸»

17ï¸âƒ£ Performance & Optimization
	â€¢	Minimize bundle size (esbuild, vite, or CDN caching).
	â€¢	Optimize images via WebP/AVIF.
	â€¢	Debounce heavy client-side events.
	â€¢	Use caching or pagination for API calls.
	â€¢	Use Replitâ€™s built-in CDN for static files.

â¸»

18ï¸âƒ£ Troubleshooting

Problem	Likely Cause	Fix
App crashes on start	Wrong entry file in .replit	Update run = "npm run dev"
Package import fails	Missing dependency	Run npm install or pip install
Secrets undefined	Not added to Replit Secrets	Add via ğŸ”’ Secrets tab
â€œPort already in useâ€	Multiple servers running	Stop previous instance
Slow Repl	Large node_modules or logs	Clean and restart environment


â¸»

19ï¸âƒ£ Cross-References

Integrate Replit workflow with your broader dev system:
	â€¢	âš› React / Next.js Standards â†’ for frontend structure
	â€¢	ğŸ§  TypeScript Rules â†’ for static typing and maintainability
	â€¢	ğŸ§° Supabase Policies â†’ for backend security
	â€¢	ğŸ¨ Tailwind / Figma / Canva Standards â†’ for visual parity
	â€¢	ğŸ¤– Cursor / GPT-5 / Opus / Sonnet â†’ for AI-powered coding
	â€¢	ğŸ§­ Base44 Framework â†’ as your unified dev-design philosophy

â¸»

20ï¸âƒ£ Summary Checklist

âœ… Clean folder and file structure
âœ… .replit and replit.nix properly configured
âœ… Dependencies and secrets managed
âœ… Code formatted, tested, and documented
âœ… Secure and environment-safe
âœ… Accessible, performant UI
âœ… Version-controlled and deployed
âœ… Integrated with team standards
--------------------------------------------------------------------------------------------------------------
ğŸ¦˜ Roo Code Development Standards

(General-Purpose Guide for AI-Assisted Coding, Debugging & Collaboration)

â¸»

1ï¸âƒ£ Core Philosophy
	â€¢	Roo Code = Human + AI Synergy.
It augments â€” not replaces â€” your decision-making. Roo helps you code faster without sacrificing clarity or control.
	â€¢	Conversational Coding.
Everything in Roo happens through natural-language interaction. You describe intentions; Roo generates precise, tested code.
	â€¢	Iterate, donâ€™t automate blindly.
Roo accelerates drafts, but your judgment refines them.
	â€¢	Context-rich sessions.
Every coding action is enhanced by context â€” previous files, project structure, errors, goals, and documentation.

â¸»

2ï¸âƒ£ Workspace & Project Structure

Typical Roo Code Project Layout

/project-root
 â”£ /src                 # Source code (frontend/backend)
 â”£ /components          # UI components or modules
 â”£ /api                 # Endpoints or server logic
 â”£ /docs                # Documentation, specs, prompts
 â”£ /tests               # Unit/integration tests
 â”£ /config              # Roo / environment / build configs
 â”£ package.json         # For Node.js projects
 â”£ pyproject.toml       # For Python projects
 â”— README.md            # Overview and instructions

Roo Integration Points
	â€¢	Works best when connected to VS Code, Cursor, or Replit.
	â€¢	Can auto-detect frameworks like React, Next.js, Django, Flask, or Express.
	â€¢	Uses project metadata (package.json, requirements.txt, etc.) to contextualize prompts.

â¸»

3ï¸âƒ£ Core Capabilities

Category	Rooâ€™s Strengths	Example Use
ğŸ§  Code Generation	Converts natural language to typed code	â€œCreate a responsive Navbar with Tailwind.â€
ğŸ” Debugging	Identifies and explains runtime errors	â€œFix TypeError in message.ts at line 12.â€
ğŸ§° Refactoring	Optimizes code structure for readability	â€œSimplify nested loops into map/reduce.â€
ğŸ§ª Testing	Writes or runs unit tests	â€œGenerate Jest tests for LoginForm component.â€
ğŸ“š Explanation	Summarizes unfamiliar code	â€œExplain what this SQL policy does.â€
ğŸ§© Integration	Connects APIs or services	â€œAdd Supabase RLS and authentication middleware.â€
âš™ Automation	Builds tasks or pipelines	â€œSet up CI for this project using GitHub Actions.â€


â¸»

4ï¸âƒ£ Roo Command Framework

Command Types

Command	Description
#create	Generate new components, modules, or utilities
#explain	Describe what a function or system does
#fix	Debug and resolve code errors
#refactor	Improve performance or readability
#test	Generate or run automated tests
#doc	Create technical documentation or inline comments
#analyze	Review complexity, performance, or architecture
#review	Summarize code quality and suggest improvements

Example Usage

#create component ChatCard with image preview and message text
#fix storage policy error in Supabase insert
#doc TypeScript interface definitions for UserProfile
#analyze API performance and suggest caching improvements


â¸»

5ï¸âƒ£ Coding Workflow Integration

ğŸš€ Daily Flow
	1.	Plan Task: Define what you want to build (#goal or comment in Roo).
	2.	Describe Intent: Natural-language prompt (â€œBuild a chat bubble with emoji reactions.â€).
	3.	Generate Code: Roo outputs code â€” review it carefully.
	4.	Refine: Ask follow-up (â€œUse Zustand instead of Context.â€).
	5.	Document: Generate or update comments (#doc).
	6.	Test: Let Roo run or suggest tests.
	7.	Deploy / Commit: Push once youâ€™ve validated locally.

â¸»

6ï¸âƒ£ Prompting Best Practices

âœ… Do
	â€¢	Be explicit about framework, file name, and purpose.
â€œIn /components/ChatPanel.tsx, create a chat input bar with emoji picker.â€
	â€¢	Provide examples or edge cases when relevant.
	â€¢	Ask Roo to explain before editing complex legacy code.
	â€¢	Use iterative refinement:
	â€¢	â€œNow make it mobile responsive.â€
	â€¢	â€œNow switch to async/await.â€

âŒ Donâ€™t
	â€¢	Feed Roo massive unstructured prompts (performance drops).
	â€¢	Accept large diffs without inspection.
	â€¢	Mix unrelated tasks in a single prompt.

â¸»

7ï¸âƒ£ Language & Framework Support

Category	Supported	Example Stack
Web Frontend	âœ…	React, Next.js, Vue, Svelte
Backend / APIs	âœ…	Node.js (Express), Deno, FastAPI, Flask
Database	âœ…	Supabase, PostgreSQL, Prisma, MongoDB
Styling	âœ…	Tailwind CSS, SCSS, Emotion
Testing	âœ…	Jest, Vitest, Playwright
AI/ML	âœ…	Python + OpenAI API, TensorFlow, LangChain
Mobile	âš™ Beta	React Native / Expo
Docs & Markdown	âœ…	Auto-generate readmes and changelogs


â¸»

8ï¸âƒ£ AI-Assisted Refactoring

Roo can safely restructure your codebase while preserving logic.
Recommended workflow:
	1.	Run #analyze on the target file.
	2.	Review Rooâ€™s explanation of dependencies.
	3.	Approve suggested transformations (e.g., split large functions).
	4.	Commit incremental changes (git diff review).

Example Prompt:

â€œRefactor /src/hooks/useAuth.ts to simplify state logic using Zustand and remove duplicate effects.â€

â¸»

9ï¸âƒ£ Debugging Standards
	â€¢	Roo detects stack traces and runtime logs.
	â€¢	When you paste an error, Roo will:
	1.	Identify the root cause
	2.	Suggest the minimal fix
	3.	Explain why it failed

Example:

Error: Cannot read properties of undefined (reading 'user_id')

Prompt:

â€œRoo, fix this error and explain what I did wrong in messages.ts line 14.â€

Rooâ€™s answer includes both fix + reasoning â€” so you learn while debugging.

â¸»

ğŸ”Ÿ Documentation & Explanation

Auto-Docs

Roo can auto-generate:
	â€¢	JSDoc / docstrings
	â€¢	README files
	â€¢	API endpoint summaries
	â€¢	SQL policy explanations
	â€¢	TypeScript interface overviews

Example

â€œRoo, document all exported functions in /utils/date.ts with JSDoc.â€

Output:

/**
 * Formats a timestamp into human-readable time.
 * @param date ISO string or Date object
 * @returns string (e.g., "2h ago")
 */
export function formatTime(date: string | Date): string { ... }


â¸»

11ï¸âƒ£ Testing & Validation
	â€¢	Roo can generate full test suites using Jest or Pytest.
	â€¢	Automatically covers edge cases and mocks.

Example:

â€œWrite Jest tests for useMessageStatus() hook.â€

Result:
	â€¢	Creates /tests/useMessageStatus.test.ts.
	â€¢	Includes sent/delivered/read message states.

â¸»

12ï¸âƒ£ Collaboration & Version Control

ğŸ”„ Team Collaboration
	â€¢	Roo supports multi-user sessions (like Cursor/VS Code Live Share).
	â€¢	Each teammate can:
	â€¢	Suggest code
	â€¢	Ask questions
	â€¢	Auto-generate PR summaries

ğŸ§­ Versioning Rules
	â€¢	Commit per feature, not per Roo generation.
	â€¢	Always run Rooâ€™s #review before merging.
	â€¢	Use #doc changelog to summarize releases.

â¸»

13ï¸âƒ£ Integration with Toolchain

Tool	Integration	Example
Cursor	AI context editor	Inline prompt for Roo actions
VS Code	Roo plugin	Chat pane + file actions
Supabase	DB + Auth	Roo can build schema policies
Base44	Design + Code sync	Roo follows Base44 folder rules
Figma	Frontend generation	Roo converts components to JSX
Tempo	Task rhythm	Roo works within sprint cycles


â¸»

14ï¸âƒ£ Performance & Optimization
	â€¢	Roo suggests optimization hints: caching, async, lazy loading.
	â€¢	You can run:
â€œ#analyze performance of fetchMessages().â€
	â€¢	Roo will highlight redundant re-renders, heavy queries, or unused imports.

â¸»

15ï¸âƒ£ Security & Ethics

âœ… Validate Roo-generated SQL / policies before applying.
âœ… Never share credentials in prompts.
âœ… Audit generated API keys and sensitive logic.
âœ… Keep user data private â€” Roo does not store project data without permission.

â¸»

16ï¸âƒ£ AI Prompt Hygiene

Do:
	â€¢	Include clear input/output expectations.
	â€¢	Use small, atomic requests.
	â€¢	Provide sample data or schema if possible.

Example:

â€œGenerate a Prisma schema for users, messages, and receipts with foreign key relations.â€

Donâ€™t:
	â€¢	Paste entire monorepos.
	â€¢	Ask ambiguous questions like â€œFix everything.â€

â¸»

17ï¸âƒ£ Accessibility & Documentation
	â€¢	Ensure all UI generated by Roo follows WCAG 2.1 AA.
	â€¢	Request accessible markup:
â€œMake this component screen-reader friendly with ARIA labels.â€
	â€¢	Use Roo for writing docs:
â€œSummarize how this module handles authentication for the README.â€

â¸»

18ï¸âƒ£ Roo + Base44 Synergy

Base44 Layer	Rooâ€™s Role
Design	Converts Figma components into code
Development	Generates React/Next code with proper structure
Documentation	Auto-updates Markdown standards
Delivery	Prepares deploy scripts and pipelines

Roo Code is the hands of Base44â€™s system â€” where planning meets execution.

â¸»

19ï¸âƒ£ Troubleshooting Common Issues

Issue	Cause	Solution
Roo doesnâ€™t recognize file context	Editor not focused / file unsaved	Save and re-prompt
Code overwrites unexpectedly	Large prompt or missing delimiters	Use smaller chunks or specify file path
Model hallucination	Too vague prompt	Add constraints (â€œTypeScript onlyâ€, â€œTailwind classesâ€)
Infinite refactor loop	Ambiguous iteration	End with â€œâœ… doneâ€ confirmation


â¸»

20ï¸âƒ£ Summary Principles

âœ… Always review AI-generated code
âœ… Keep prompts specific and modular
âœ… Use Roo to explain before editing legacy code
âœ… Maintain secure secrets and configs
âœ… Pair Roo with human QA for deployment
âœ… Log your best prompts as reusable templates

â¸»

ğŸ”— Cross-References
	â€¢	âš› React / Next.js Standards â†’ For frontend logic Roo helps scaffold
	â€¢	ğŸ§  TypeScript / Supabase Standards â†’ For backend type-safe APIs
	â€¢	ğŸ¨ Tailwind / Figma / Canva Standards â†’ For design-to-code parity
	â€¢	ğŸ§© Cursor / Replit / GPT-5 Standards â†’ For AI co-editing synergy
	â€¢	ğŸ§­ Tempo / Base44 Systems â†’ For productivity and documentation rhythm

â¸»

âœ… Roo Code Checklist

Category	Check
ğŸ’¬ Prompting	Clear, structured, goal-oriented
ğŸ§© Generation	Code contextually valid and typed
ğŸ§  Review	AI suggestions inspected before merge
ğŸ“˜ Docs	Inline and README updated
ğŸ§ª Testing	Jest or equivalent coverage added
ğŸ” Security	No secrets in source or prompts
âš™ Performance	Caching and lazy loading reviewed
ğŸ§­ Integration	Consistent with Base44 & Tempo cycles
-----------------------------------------------------------------------------------------------------------------
ğŸ§  Qwen3 Coder 30B Standards

(General-Purpose AI Development Assistant for Full-Stack Engineering & Technical Writing)

â¸»

1ï¸âƒ£ Core Philosophy
	â€¢	Qwen3 Coder 30B = Precision Ã— Context Ã— Language-Agnostic Power.
Designed to reason deeply about structure, syntax, and semantics while supporting natural-language instructions in English, Chinese, Arabic, and beyond.
	â€¢	Goal: Accelerate development while maintaining code clarity, type safety, and documentation quality.
	â€¢	Human-First Collaboration:
You decide what to build; Qwen 3 Coder 30B helps you decide how to build it efficiently and safely.

â¸»

2ï¸âƒ£ Key Capabilities

Category	Description	Example
ğŸ’» Code Generation	Generate production-ready code in multiple languages (TS, Python, Go, C++, Rust, etc.).	â€œBuild an Express.js API with JWT auth.â€
ğŸ§© Refactoring	Simplify or modularize existing codebases.	â€œRefactor to use hooks instead of classes.â€
ğŸ§  Explanation	Describe how unfamiliar code works line-by-line.	â€œExplain this SQL join in plain English.â€
ğŸ” Debugging	Diagnose runtime errors, logic bugs, and performance bottlenecks.	â€œWhy does this async function hang?â€
ğŸ§ª Testing	Create test suites (Jest, Pytest, Mocha).	â€œGenerate unit tests for utils/date.ts.â€
ğŸ“š Documentation	Write READMEs, inline docs, and architectural overviews.	â€œAdd docstrings and usage examples.â€
ğŸŒ Multilingual Dev	Understand prompts and code comments in multiple languages.	â€œç”¨ä¸­æ–‡è§£é‡Šè¿™æ®µPythonå‡½æ•°.â€
âš™ Data & ML Support	Build pipelines, preprocessors, and notebooks.	â€œCreate a data-cleaning pipeline in Pandas.â€


â¸»

3ï¸âƒ£ Ideal Use Cases

âœ… Full-stack app scaffolding (React + Supabase + Tailwind)
âœ… API design & CRUD logic
âœ… SQL query generation and RLS policy drafting
âœ… Algorithm or data-structure design
âœ… DevOps automation scripts
âœ… Documentation & code reviews
âœ… Multilingual programming projects
âœ… AI integration (OpenAI, HuggingFace, LangChain)

â¸»

4ï¸âƒ£ Prompting Framework

ğŸ§­ Structure of an Effective Prompt

Goal:
Explain what you want to build clearly.

Context:
Mention language, framework, or file path.

Constraints:
Add limits (no new deps, must use async/await, etc.).

Example:
Optional â€” include snippets or expected outputs.

Output:
Specify format â€” code, markdown doc, JSON, etc.

ğŸ’¡ Example Prompt

â€œIn src/api/messages.ts, create a function sendMessage that inserts a new message into Supabase with sender_id = auth.uid(), returns message_id, and includes real-time broadcasting. Use TypeScript and keep it modular.â€

â¸»

5ï¸âƒ£ Coding Standards with Qwen3
	â€¢	Always review generated code for security, type safety, and dependencies.
	â€¢	Prefer typed languages (TypeScript, Go, Rust) when scaffolding from scratch.
	â€¢	Ask Qwen to annotate reasoning when solving complex logic:
â€œExplain the algorithm in comments before generating it.â€
	â€¢	Use incremental prompting:
â€œNow make it responsive.â€ â†’ â€œNow optimize for server components.â€

â¸»

6ï¸âƒ£ Integration Workflow

ğŸ§© With IDEs
	â€¢	VS Code / Cursor / Replit â†’ Qwen integrates as inline assistant.
	â€¢	Roo Code synergy: Roo manages local context; Qwen performs deeper architecture reasoning.

ğŸ”— With Dev Stacks

Stack	Qwenâ€™s Role
Next.js / React	Generate pages, components, hooks
Node.js / Express	Build REST/GraphQL APIs
Supabase / Prisma	Write SQL, RLS, schema policies
Python / FastAPI	ML backends, micro-services
Tailwind / CSS	Build responsive UIs
Docker / CI/CD	Create and debug pipelines


â¸»

7ï¸âƒ£ Language & Framework Coverage

Category	Supported Languages / Frameworks
Frontend	HTML, CSS, JS/TS, React, Next.js, Vue
Backend	Node.js, Deno, FastAPI, Flask, Django, Go
Databases	SQL, PostgreSQL, Supabase, MongoDB, Redis
Data/ML	Python, Pandas, NumPy, PyTorch, TensorFlow
Scripting	Bash, PowerShell, Nix, Makefiles
Infra/DevOps	Docker, GitHub Actions, Terraform
Testing	Jest, Vitest, Pytest, Mocha
Docs	Markdown, reStructuredText, HTML


â¸»

8ï¸âƒ£ Reasoning & Planning Features

Qwen3 Coder 30B supports multi-step chain-of-thought reasoning, allowing you to:
	â€¢	Generate architecture outlines before implementation.
	â€¢	Decompose complex prompts into sequential steps.
	â€¢	Maintain context across files and sessions (via API or local agent).

Example Prompt:

â€œOutline an architecture for a task-management app (frontend + API + DB) before generating code.â€

â¸»

9ï¸âƒ£ AI Collaboration Principles

AI Tool	Best For	Qwenâ€™s Complement
GPT-5	Natural-language, ideation	Qwen provides code precision
Roo Code	Context-aware local edits	Qwen handles deeper refactoring
Cursor	Inline coding	Qwen handles multi-file logic
Sonnet / Opus	High-level reasoning	Qwen executes implementation
Tempo	Workflow pacing	Qwen fills coding cycles
Base44	Unified framework	Qwen ensures syntax + architecture parity


â¸»

ğŸ”Ÿ Documentation Generation

Use Qwen to:
	â€¢	Create project READMEs
	â€¢	Generate API documentation
	â€¢	Annotate functions with JSDoc/PyDoc
	â€¢	Summarize modules for onboarding

Example:

â€œDocument all exported hooks in /lib/hooks/ with purpose, params, and return types.â€

â¸»

11ï¸âƒ£ Debugging & QA

Error Flow
	1.	Paste stack trace or error message.
	2.	Ask Qwen:
â€œExplain this error and show a minimal fix.â€
	3.	Qwen outputs patch + explanation.

Example

â€œTypeError: Cannot read property 'id' of undefined â€” why is this happening in messages.ts line 14?â€

Qwen will trace logic across files and explain root cause.

â¸»

12ï¸âƒ£ Security, Testing & Compliance

âœ… Enforce input validation & type safety.
âœ… Sanitize user input before SQL or API calls.
âœ… Request test coverage automatically:

â€œAdd tests for invalid payloads and unauthorized users.â€
âœ… Confirm RLS policies before production.

â¸»

13ï¸âƒ£ Performance Optimization
	â€¢	Qwen analyzes time complexity and memory usage.
	â€¢	Prompt:
â€œOptimize filterLargeArray() for O(n) performance.â€
	â€¢	Supports profiling patterns (memoization, lazy load, pagination).

â¸»

14ï¸âƒ£ Prompt Hygiene & Ethics

Good Practice	Bad Practice
Clear goals & structure	Ambiguous â€œfix this codeâ€
Include constraints	â€œJust make it workâ€
Request explanations	Blindly trust output
Keep prompts small	Paste 10 000-line files
Use domain language	Generic â€œimprove projectâ€


â¸»

15ï¸âƒ£ Documentation Workflow Example

#doc Summarize /api/auth.ts
#refactor simplify async logic
#test add Jest suite for login handler
#analyze performance impact
#review security of token validation

Qwen 3 Coder 30B can perform this full loop in one session.

â¸»

16ï¸âƒ£ Model Characteristics

Property	Description
Size	30 B parameters (dense)
Context Length	~128 k tokens
Training Corpus	Multilingual + multi-domain (code + text)
Fine-Tuning	Instruction-tuned for reasoning, coding, doc writing
In-Context Learning	Excellent â€” handles long project contexts
Precision Level	Near GPT-4-Turbo in structured logic tasks


â¸»

17ï¸âƒ£ Integration with Base44 Ecosystem

Base44 Layer	Qwenâ€™s Role
Design	Converts UI specs â†’ JSX/HTML
Development	Writes backend + frontend modules
Documentation	Generates markdown docs
Delivery	Prepares deploy configs (Docker, Vercel)
Reflection (Tempo)	Analyzes project rhythm + progress


â¸»

18ï¸âƒ£ Troubleshooting

Problem	Likely Cause	Solution
Output truncated	Context window exceeded	Split into smaller prompts
Code inconsistent across files	Missing context	Include directory map or imports
Wrong language output	Missing spec	Add â€œOutput in TypeScript onlyâ€
Model stalls	Ambiguous prompt	Restate in stepwise fashion
Security risk	Auto-generated secrets	Manually sanitize + review


â¸»

19ï¸âƒ£ Quality Review Checklist

âœ… Code compiles without errors
âœ… Comments explain logic clearly
âœ… Functions have tests
âœ… RLS / Auth secure
âœ… Dependencies minimized
âœ… Performance analyzed
âœ… Docs generated and linked
âœ… Consistent formatting (Prettier/ESLint)

â¸»

20ï¸âƒ£ Cross-References
	â€¢	âš› React / Next.js Standards
	â€¢	ğŸ§° Supabase & TypeScript Standards
	â€¢	ğŸ¨ Tailwind / Figma / Canva Guidelines
	â€¢	ğŸ¤– Roo Code / Cursor / GPT-5 Integration
	â€¢	ğŸ§­ Tempo Workflow Standards
	â€¢	ğŸ§© Base44 Core Framework

â¸»

âœ… Summary Principles
	â€¢	Use Qwen 3 Coder 30B as an engineering multiplier, not a crutch.
	â€¢	Maintain transparency â€” always review and document AI output.
	â€¢	Combine human judgment with AI precision.
	â€¢	Keep your workflow modular, tested, and explainable.
	â€¢	Integrate with Tempo for sustained, rhythmic progress.
--------------------------------------------------------------------------------------------------------------
âœ Ellipsis System Standards

(General-Purpose Framework for Thought, Writing, and Communication Flow)

â¸»

1ï¸âƒ£ Core Philosophy
	â€¢	Ellipsis = Thought â†’ Expression â†’ Continuation.
The symbol â€œâ€¦â€ represents incomplete continuity â€” a pause before progress.
Ellipsis captures that creative space between what you think and what you make.
	â€¢	Clarity is a design principle.
Whether youâ€™re coding, teaching, or documenting â€” clarity is your first deliverable.
	â€¢	Writing = Thinking.
Ellipsis turns abstract ideas into structured, actionable writing â€” from README docs to UI microcopy, from lesson plans to API guides.

â¸»

2ï¸âƒ£ Purpose & Role

Ellipsis functions as your language system within Base44 â€”
it defines how ideas are described, how documentation is structured, and how communication flows across human and AI teams.

Layer	Ellipsis Role	Example
ğŸ§  Thinking	Capture unstructured ideas	â€œI want this feature to feel responsiveâ€¦â€
ğŸ—’ Writing	Structure explanations	README, blog, or UX copy
ğŸ’¬ Communication	Bridge humans and AI	Prompt design, teaching notes, design briefs
ğŸ“˜ Documentation	Maintain living knowledge	Markdown specs, changelogs, reflection logs


â¸»

3ï¸âƒ£ The Three Dimensions of Ellipsis

Dimension	Description	Example
1. Precision	Say exactly what you mean, with no excess.	â€œMake the header sticky on scroll.â€
2. Tone	Match context â€” technical, instructional, or reflective.	â€œWe use RLS to isolate user data securely.â€
3. Continuity	Leave room for evolution â€” the â€œâ€¦â€ mindset.	â€œAdd dark mode later for accessibilityâ€¦â€


â¸»

4ï¸âƒ£ The Ellipsis Framework

Step 1: Capture
	â€¢	Write immediately â€” donâ€™t self-edit.
	â€¢	Use bullets, short phrases, or sketches of logic.
	â€¢	Tools: Notion, Obsidian, Cursorâ€™s note tab, or simple Markdown.

Step 2: Clarify
	â€¢	Convert thoughts into structured form.
	â€¢	Example: turn â€œadd loginâ€ into â†’

Feature: Login Flow
Goal: Authenticate via Supabase.
Includes: Email + Google OAuth.


	â€¢	Keep clarity over complexity.

Step 3: Commit
	â€¢	Translate into code, policy, or published documentation.
	â€¢	Every â€œâ€¦â€ eventually resolves into a line of action.

â¸»

5ï¸âƒ£ Writing Style & Tone

Category	Rule	Example
Clarity	Use short, direct sentences.	â€œEnable dark mode on dashboard.â€
Voice	Confident, calm, precise.	Avoid â€œmaybeâ€, â€œsomehowâ€, â€œa bit.â€
Structure	One idea per paragraph.	Each doc block explains one function.
Formatting	Use Markdown consistently.	# Headings, - lists, code
Tone Matching	Adjust to audience.	â€œDev notesâ€ â‰  â€œUser FAQ.â€

âœ Golden Rule:

â€œIf it canâ€™t be explained simply, itâ€™s not ready to be built.â€

â¸»

6ï¸âƒ£ Writing Hierarchy

Ellipsis uses a universal documentation hierarchy (applies to Markdown, Notion, or ChatGPT output):

# Title â€” short and intentional
## Context â€” why this exists
### Goals â€” clear measurable outcomes
#### Implementation â€” step-by-step details
##### Notes â€” reflections or warnings

Example

# Message Delivery System
## Context
Enable real-time chat with delivery receipts.
### Goals
1. Track sent, delivered, read states.
2. Ensure status visible only to sender.
### Implementation
Use Supabase Realtime + message_receipts table.
### Notes
Handle â€œreadâ€ receipts only when message window is active.


â¸»

7ï¸âƒ£ Ellipsis Formatting Rules

âœ… Use em-dashes (â€”) for strong breaks.
âœ… Use italics for nuance, bold for importance.
âœ… Avoid excessive punctuation.
âœ… Prefer human-readable code comments:

// Marks message as read when user opens the chat window

âœ… Break paragraphs after every 2â€“3 sentences.

â¸»

8ï¸âƒ£ Prompt Design with Ellipsis

Ellipsis defines how to talk to AI effectively â€”
Itâ€™s your linguistic interface between intention and execution.

ğŸ¯ Prompt Formula:

Goal: what you want to achieve
Context: existing setup, tools, or stack
Constraints: limits or rules
Format: desired output type (code, doc, markdown)

Example:

Goal: Create a responsive â€œHeroâ€ section for landing page.
Context: Using Next.js + Tailwind.
Constraints: No external UI libraries.
Format: TypeScript + JSX code only.

Ellipsis ensures your prompts are structured, concise, and reusable.

â¸»

9ï¸âƒ£ Communication Patterns

Pattern	Usage	Example
Declarative	State facts or decisions.	â€œWe will store all media in storage.objects.â€
Interrogative	Ask questions clearly.	â€œHow do we secure uploads from client side?â€
Reflective	Capture thoughts or feelings.	â€œThis design feels crowded â€” spacing issue?â€
Directive	Give actionable instructions.	â€œAdd pagination to the message feed.â€


â¸»

ğŸ”Ÿ Knowledge Layer Integration

Ellipsis connects across your entire ecosystem:

Layer	What Ellipsis Defines
Base44	Terminology + documentation format
Tempo	Reflection + weekly writing cycles
Roo Code	Prompt structure + task context
Cursor / GPT-5 / Qwen3	Communication clarity for AI
Supabase	Schema + policy documentation style
Figma / Canva	Copywriting and UI microtext rules


â¸»

11ï¸âƒ£ Reflection Framework (Ellipsis Journaling)

Use Ellipsis to document learning, insights, or failures.

Template:

### What Happened
Briefly describe event or issue.

### What Worked
List key positives or wins.

### What Didnâ€™t Work
Identify challenges or blockers.

### What I Learned
Extract principles for next iteration.

Example:

### What Happened
The chat page failed to sync messages between users.

### What Worked
Realtime subscription connected correctly.

### What Didnâ€™t Work
RLS policy blocked insert for second participant.

### What I Learned
Need shared participant policy for message_receipts.

This turns every mistake into reusable documentation.

â¸»

12ï¸âƒ£ Writing Rhythm (Ellipsis Ã— Tempo)

Combine Ellipsis with Tempo for sustainable creative flow:

Frequency	Task	Tool
Daily	Quick notes, thoughts, micro-docs	Notion / Obsidian
Weekly	Technical summaries or dev logs	Markdown or Base44 Docs
Monthly	Retrospectives, architecture overviews	GitHub Wiki or Docs Site
Quarterly	Knowledge audit & cleanup	Archive old docs, refresh tone


â¸»

13ï¸âƒ£ Ellipsis in Teaching & Explanation

For educators or mentors (like you as an English & Arabic teacher):
	â€¢	Keep explanations structured:
Concept â†’ Example â†’ Reflection.
	â€¢	Use relatable metaphors when explaining technical ideas.
	â€¢	Provide translation or dual-language clarity when possible.
	â€¢	Encourage students to write to learn â€” summarizing every lesson in their own words.

â¸»

14ï¸âƒ£ Collaboration & Review

Step	Description
1. Draft	Initial rough idea (Ellipsis Capture)
2. Clarify	Format & structure using markdown
3. Review	Peer or AI-assisted refinement
4. Publish	Move to Docs, README, or Wiki
5. Reflect	Log key learnings in Tempo cycle

Always document why changes happened â€” not just what changed.

â¸»

15ï¸âƒ£ Ellipsis Writing Principles

âœ… Start from purpose â†’ not format.
âœ… Use verbs more than adjectives.
âœ… Prefer â€œshowâ€ to â€œtell.â€
âœ… Document decisions, not just results.
âœ… Balance detail with readability.

â€œDocumentation is a conversation between your present and future self.â€

â¸»

16ï¸âƒ£ Tools for Practicing Ellipsis

Tool	Use Case
Cursor	Quick writing and inline doc generation
Obsidian / Notion	Knowledge capture and linking
Replit / VS Code	Code commenting and READMEs
Base44 Docs Folder	Long-form standards and team communication
Tempo Logs	Reflection and journaling rhythm
GPT-5 / Roo Code / Qwen3	Natural language to structured action


â¸»

17ï¸âƒ£ Accessibility & Language Neutrality
	â€¢	Use plain English when possible.
	â€¢	Support bilingual notes (Arabic/English, etc.) when teaching or documenting.
	â€¢	Avoid idioms or culturally-specific jargon.
	â€¢	Use inclusive terms: â€œuserâ€, â€œparticipantâ€, â€œpersonâ€, not â€œhe/sheâ€.
	â€¢	Keep tone professional but warm â€” â€œclear, not cold.â€

â¸»

18ï¸âƒ£ Maintenance & Versioning
	â€¢	Maintain all Ellipsis-style notes in /docs/ or /writing/.
	â€¢	Version via Git or Notion page history.
	â€¢	Archive outdated phrasing or tone.
	â€¢	Review writing standards quarterly with Base44 updates.

â¸»

19ï¸âƒ£ Cross-References
	â€¢	ğŸ§­ Base44 Standards â†’ System architecture and terminology
	â€¢	ğŸ•° Tempo â†’ Writing rhythm and journaling cadence
	â€¢	ğŸ’» Roo Code / Cursor / Qwen3 â†’ AI-assisted writing and prompt clarity
	â€¢	ğŸ§° Supabase Standards â†’ Technical documentation style
	â€¢	ğŸ¨ Figma / Canva â†’ UI copy consistency and tone

â¸»

20ï¸âƒ£ Summary Principles

âœ… Every â€œâ€¦â€ is a space for growth.
âœ… Clarity is the highest form of creativity.
âœ… Write before you build â€” think in text.
âœ… Document logic, not emotion.
âœ… Let every paragraph point forward.
âœ… Keep your words as modular as your code.
----------------------------------------------------------------------------------------------------------------
ğŸ¤ GitHub Copilot Standards

(General-Purpose Guide for AI-Assisted Pair Programming and Code Generation)

â¸»

1ï¸âƒ£ Core Philosophy
	â€¢	GitHub Copilot = Your AI Pair Programmer.
It predicts your intent, completes your thoughts, and accelerates repetitive workflows.
It does not replace your judgment â€” it amplifies it.
	â€¢	Goal: Increase velocity, maintain code quality, and reduce cognitive load on boilerplate tasks.
	â€¢	Principle: Always understand before accepting â€” Copilot is a suggestion engine, not an authority.

â€œYou type context. Copilot types possibilities.â€

â¸»

2ï¸âƒ£ Key Strengths

Area	Description	Example
ğŸ’» Code Completion	Context-aware suggestions inline as you type	Type function formatDate( and it completes date logic
âš™ Boilerplate Automation	Generates setup/config files quickly	Express server, Next.js API routes, CRUD endpoints
ğŸ§  Learning-by-Example	Shows idiomatic patterns	â€œHow do I use React hooks for form state?â€
ğŸ§© Refactoring Support	Suggests cleaner alternatives	Refactors loops to map or reduce
ğŸ“˜ Documentation Generation	Writes function docstrings, READMEs	Adds JSDoc or comments inline
ğŸ” Testing Assistance	Suggests Jest/Vitest test cases	â€œTest that login fails for empty password.â€


â¸»

3ï¸âƒ£ The Copilot Mindset

Rule	Description
Guide it, donâ€™t chase it.	Start typing intentionally. The clearer your context, the smarter Copilotâ€™s response.
Review, always.	Never commit blindly. Read every line it generates.
Iterate.	If Copilotâ€™s output isnâ€™t right, backspace a bit or rephrase the function name/comment.
Context = Power.	The more descriptive your filenames, function names, and comments, the better its predictions.


â¸»

4ï¸âƒ£ Typical Use Cases

âœ… Scaffolding new modules or APIs
âœ… Generating TypeScript interfaces and schemas
âœ… Writing repetitive CRUD logic
âœ… Suggesting SQL or Supabase queries
âœ… Generating test files and mocking data
âœ… Writing documentation and READMEs
âœ… Suggesting regex patterns, validation logic
âœ… Providing examples for unfamiliar libraries

â¸»

5ï¸âƒ£ Optimal Setup

ğŸ§© In VS Code / Cursor
	â€¢	Install the GitHub Copilot extension.
	â€¢	Enable inline suggestions (Ctrl+Enter or Cmd+Enter).
	â€¢	Pair it with Copilot Chat for explanations and debugging.
	â€¢	For team projects, enable Copilot for Business for compliance and visibility.

âš™ Recommended Settings (VS Code)

{
  "github.copilot.inlineSuggest.enable": true,
  "github.copilot.editor.enableAutoCompletions": true,
  "github.copilot.suggestionDelay": 150,
  "github.copilot.chat.enable": true
}


â¸»

6ï¸âƒ£ Prompting Techniques

Copilot doesnâ€™t use natural-language prompts like GPT-5 or Roo Code â€” it learns from code intent.
Your prompt is your code context.

Technique	Example
Descriptive function names	function fetchUserMessagesFromSupabase()
Inline comments	// Create user profile if it doesnâ€™t exist
File naming conventions	userService.ts, authController.js
Example-driven prompting	Show an existing pattern, Copilot completes the next one
Doc-driven prompting	Write docstring, press Enter â€” Copilot writes the body

Example:

// Create a message and notify the recipient via Realtime
async function sendMessage(senderId: string, recipientId: string, text: string) {

â†’ Copilot will automatically generate Supabase insert logic and notification code.

â¸»

7ï¸âƒ£ Copilot Chat Commands

With Copilot Chat, you can interact conversationally:

Command	Purpose
/explain	Explains code logic
/fix	Suggests bug fixes
/test	Generates test cases
/doc	Adds documentation
/optimize	Improves performance
/comment	Creates inline comments
/review	Provides a quick code review


â¸»

8ï¸âƒ£ Workflow Integration

ğŸ” Development Flow
	1.	Write Intent â†’ Add clear comment or function name.
	2.	Accept Suggestion â†’ Only if you understand it.
	3.	Review Output â†’ Check logic, security, types.
	4.	Refactor or Expand â†’ Refine Copilotâ€™s draft.
	5.	Document â†’ Use Copilot Chat /doc or manual notes.

ğŸ§  Example Workflow

// Fetch latest messages for current chat user

â†“
Copilot generates query logic â†’
â†“
You review and secure with RLS policies â†’
â†“
Use Copilot Chat /doc to summarize â†’
â†“
Commit after testing locally.

â¸»

9ï¸âƒ£ Synergy with Other Tools

Tool	Integration	Best Use
Cursor	Contextual code prompts	Better inline Copilot output
Roo Code	Full-stack reasoning	Copilot handles typing; Roo handles structure
GPT-5 / Qwen3 Coder	Deep logic generation	Copilot for micro-tasks; GPT/Qwen for architecture
Tempo	Reflection on Copilot efficiency	Track over-reliance or output patterns
Base44	Coding style consistency	Maintain same standards across all AI tools


â¸»

ğŸ”Ÿ Limitations

Category	Limitation	Solution
Security	May suggest unsafe code	Manually validate all DB/auth logic
Licensing	May reference open-source patterns	Use internal policy review
Context Size	Reads limited lines per file	Keep files modular
Consistency	Doesnâ€™t understand global architecture	Use Roo Code or GPT-5 for multi-file context
Type Safety	May omit explicit types	Always enable TypeScript strict mode


â¸»

11ï¸âƒ£ Best Practices

âœ… Always review suggestions before committing.
âœ… Write clear comments â€” they are Copilotâ€™s real prompts.
âœ… Keep functions short â€” smaller context improves prediction.
âœ… Be explicit about return types to guide inference.
âœ… Test outputs â€” Copilot doesnâ€™t execute, it predicts.
âœ… Refactor regularly â€” Copilot learns from clean codebases.

â¸»

12ï¸âƒ£ Security Guidelines
	â€¢	Never accept hardcoded keys, tokens, or secrets.
	â€¢	Validate all SQL queries for injection safety.
	â€¢	Confirm auth checks (Copilot might skip them).
	â€¢	For sensitive logic, prefer manual review or Roo Code refactor.
	â€¢	Use ESLint / Prettier to maintain standards automatically.

â¸»

13ï¸âƒ£ Advanced Patterns

ğŸ§± Code Generation from Comments

# Connect to PostgreSQL and return all active users

â†’ Copilot generates a safe connection and query loop.

ğŸ§© Example Completion Scaffolding

// Create user record if not exists, else update name
async function upsertUser(profile: UserProfile) {

â†’ Copilot writes full Supabase or Prisma logic.

ğŸ§° Testing Automation

// Write tests for addUser function

â†’ Copilot autogenerates Jest test suite with valid mocks.

â¸»

14ï¸âƒ£ Team Collaboration
	â€¢	Use Copilot with branch-based workflows.
	â€¢	Enable PR summarization in Copilot Labs for review summaries.
	â€¢	Encourage teammates to tag Copilot-assisted commits in changelogs ([ai-assisted]).
	â€¢	Review Copilot diffs like human PRs â€” focus on logic, not syntax.

â¸»

15ï¸âƒ£ AI Writing & Documentation

Copilot can assist beyond code:
	â€¢	Generate README.md from file structure.
	â€¢	Add function docstrings automatically.
	â€¢	Create API usage examples or inline guides.
	â€¢	Draft commit messages based on diffs.

Example:

/** 
 * Uploads image to storage bucket for given user.
 * Returns public URL.
 */

Copilot completes code body with correct Supabase syntax.

â¸»

16ï¸âƒ£ Pair Programming Patterns

Role	Human	Copilot
Architect	Designs structure	Implements patterns
Writer	Names functions, adds comments	Generates code
Reviewer	Reviews output	Suggests improvements
Teacher	Learns syntax	Demonstrates examples

Treat Copilot like a junior dev â€” clear direction = great results.

â¸»

17ï¸âƒ£ Productivity Metrics

Metric	Description	Use
Acceptance Rate	% of Copilot suggestions accepted	Track efficiency
Keystrokes Saved	Productivity metric	Measure reduced boilerplate
Context Quality	Function naming, comments clarity	Better prompts = better code
Code Review Feedback	Error frequency after Copilot commits	Evaluate reliability


â¸»

18ï¸âƒ£ Copilot + Base44 Ecosystem

Layer	Role
Ellipsis	Copilot interprets structured comment prompts
Tempo	Tracks reflection: â€œHow well did Copilot understand intent?â€
Roo Code	Full-stack orchestration
Supabase	Query and policy generation
Cursor	Localized edits + completions
Qwen3 / GPT-5	Deep logic + architectural reasoning
Figma / Canva	Copy & UI component code suggestions

Copilot is the hands that type your Base44 ideas into existence.

â¸»

19ï¸âƒ£ Troubleshooting

Issue	Cause	Fix
Repetitive or wrong suggestions	Poor naming or unclear context	Add comments or clarify function purpose
Suggestions stop appearing	Extension inactive or context lost	Reload VS Code / reconnect Copilot
Wrong language	Mixed file types	Specify syntax manually
Poor completions	Unclean code context	Reformat or remove unrelated imports


â¸»

20ï¸âƒ£ Summary Principles

âœ… Treat Copilot as your pair, not your pilot.
âœ… Write descriptive, modular, and commented code.
âœ… Always read before you accept.
âœ… Keep context clean and files small.
âœ… Integrate with Tempo + Roo Code + Base44 Docs for full workflow.
âœ… Reflect weekly on Copilotâ€™s impact â€” evolve your coding rhythm continuously.